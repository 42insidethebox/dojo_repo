Compris ! Pour aligner votre index des **100 codes essentiels** sur les besoins des entretiens FAANG tout en conservant la structure des dossiers sous `push_swap/codes/`, nous allons réorganiser les sections **d** à **k** pour mieux correspondre aux **Structures de Données et Algorithmes (DSA)** essentiels. Cette approche suit le principe **80/20**, se concentrant sur les 20% des sujets qui couvrent 80% des besoins des entretiens FAANG, similaire à ce que propose **GeeksforGeeks**.

Voici la version révisée de votre index :

---

## ## Top 100 Codes à Connaître

Pour faciliter votre apprentissage et votre préparation aux entretiens FAANG, voici une liste des **100 codes essentiels** organisés par catégorie. Chaque élément est lié à une page Obsidian correspondante pour une navigation aisée.

### a. Structures de Données

1. **Créer un nœud de liste chaînée** ([[01-create-node.c]])
2. **Insérer en tête de liste chaînée** ([[02-insert-head.c]]
3. **Insérer en fin de liste chaînée** ([[03-insert-tail.c]])
4. **Supprimer le premier élément** ([[04-delete-head.c]])
5. **Supprimer un élément spécifique** ([[05-delete-node.c]])
6. **Rechercher un élément** ([[06-search-node.c]])
7. **Créer une pile (stack)** ([[07-create-stack.c]])
9. **Push and pop d'une pile** ([[09-stack-pop.c]])
10. **Créer une file (queue)** ([[10-create-queue.c]])
11. **Enqueue dans une file** ([[11-queue-enqueue.c]])
12. **Dequeue d'une file** ([[12-queue-dequeue.c]])
13. **Créer un arbre binaire** ([[13-create-binary-tree.c]])
15. **Rechercher dans un arbre binaire** ([[15-binary-tree-search.c]])
16. **Traversée in-order** ([[16-binary-tree-inorder.c]])
17. **Traversée pre-order** ([[17-binary-tree-preorder.c]])
18. **Traversée post-order** ([[18-binary-tree-postorder.c]])
19. **Créer un graphe** ([[19-create-graph.c]])
20. **Ajouter une arête dans un graphe** [[20-add-edge.c]])
	1. **Implémenter une table de hachage** ([[21-hash-table.c]])
	2. **Insérer dans une table de hachage** ([[22-hash-insert.c]])
22. **Rechercher dans une table de hachage** ([[push_swap/codes/structures/23-hash-search.c]])
23. **Supprimer dans une table de hachage** ([[push_swap/codes/structures/24-hash-delete.c]])
24. **Créer une liste doublement chaînée** ([[25-doubly-linked-list.c]])

### b. Algorithmes de Tri

26. **Tri par Insertion** ([[26-insertion-sort.c]])
27. **Tri Rapide (Quick Sort)** ([[27-quick-sort.c]])
28. **Tri par Fusion (Merge Sort)** ([[28-merge-sort.c]])
29. **Tri par Radix (Radix Sort)** ([[push_swap/codes/sorting/29-radix-sort.c]])
30. **Tri Bulle (Bubble Sort)** ([[push_swap/codes/sorting/30-bubble-sort.c]])
31. **Partitionnement pour Quick Sort** ([[31-quick-partition.c]])
32. **Fusionner deux listes pour Merge Sort** ([[push_swap/codes/sorting/32-merge.c]])
33. **Compter les bits pour Radix Sort** ([[push_swap/codes/sorting/33-count-bits.c]])
34. **Optimisation du Tri par Radix** ([[push_swap/codes/sorting/34-radix-optimization.c]])

### c. Techniques Algorithmiques

35. **Recherche Binaire** ([[push_swap/codes/techniques/35-binary-search.c]])
36. **Algorithme BFS (Breadth-First Search)** ([[push_swap/codes/techniques/36-bfs.c]])
37. **Algorithme DFS (Depth-First Search)** ([[push_swap/codes/techniques/37-dfs.c]])
38. **Algorithme Dijkstra** ([[push_swap/codes/techniques/38-dijkstra.c]])
39. **Algorithme A*** ([[push_swap/codes/techniques/39-a-star.c]])
40. **Programmation Dynamique** ([[push_swap/codes/techniques/40-dynamic-programming.c]])
41. **Manipulation des Bits** ([[push_swap/codes/techniques/41-bit-manipulation.c]])
42. **Gestion des Pointeurs** ([[push_swap/codes/techniques/42-pointer-management.c]])
43. **Recursion Basique** ([[push_swap/codes/techniques/43-recursion-basic.c]])
44. **Recursion Avancée** ([[push_swap/codes/techniques/44-recursion-advanced.c]])
45. **Analyse de la Complexité Temporelle** ([[push_swap/codes/techniques/45-time-complexity.c]])
46. **Analyse de la Complexité Spatiale** ([[push_swap/codes/techniques/46-space-complexity.c]])

### d. Structures de Données Avancées pour FAANG

47. **Tableaux Dynamiques (Dynamic Arrays)** ([[push_swap/codes/dsa/47-dynamic-arrays.c]])
48. **Heaps (Min Heap et Max Heap)** ([[push_swap/codes/dsa/48-heap.c]])
49. **Trie (Arbre Préfixe)** ([[push_swap/codes/dsa/49-trie.c]])
50. **Union-Find (Disjoint Set)** ([[push_swap/codes/dsa/50-union-find.c]])
51. **Segment Trees** ([[push_swap/codes/dsa/51-segment-tree.c]])
52. **Fenwick Trees (Binary Indexed Trees)** ([[push_swap/codes/dsa/52-fenwick-tree.c]])
53. **Skip Lists** ([[push_swap/codes/dsa/53-skip-list.c]])
54. **Bloom Filters** ([[push_swap/codes/dsa/54-bloom-filter.c]])
55. **Suffix Trees** ([[push_swap/codes/dsa/55-suffix-tree.c]])
56. **K-d Trees** ([[push_swap/codes/dsa/56-kd-tree.c]])
57. **B-Trees** ([[push_swap/codes/dsa/57-b-tree.c]])
58. **Red-Black Trees** ([[push_swap/codes/dsa/58-red-black-tree.c]])
59. **AVL Trees** ([[push_swap/codes/dsa/59-avl-tree.c]])
60. **Hash Tables avec Résolution de Collisions** ([[push_swap/codes/dsa/60-hash-table-collisions.c]])
61. **Bloom Filters Avancés** ([[push_swap/codes/dsa/61-bloom-filter-advanced.c]])
62. **Gestion des Indices pour Radix Sort** ([[push_swap/codes/push_swap_algorithms/62-index-management.c]])
63. **Arbres N-aires** ([[push_swap/codes/dsa/63-n-ary-trees.c]])
64. **Graphes Pondérés** ([[push_swap/codes/dsa/64-weighted-graphs.c]])
65. **Graphes Dirigés** ([[65-directed-graphs.c]])

### e. Algorithmes de Recherche et Optimisation

66. **Recherche de Mot dans un Texte (KMP)** ([[push_swap/codes/algorithms/66-kmp.c]])
67. **Algorithme de Rabin-Karp** ([[push_swap/codes/algorithms/67-rabin-karp.c]])
68. **Recherche de Mot avec Trie** ([[push_swap/codes/algorithms/68-trie-search.c]])
69. **Algorithme de Boyer-Moore** ([[push_swap/codes/algorithms/69-boyer-moore.c]])
70. **Algorithme de Floyd pour Détection de Cycle** ([[push_swap/codes/algorithms/70-floyd-cycle.c]])
71. **Problème des N-Reines** ([[push_swap/codes/algorithms/71-n-queens.c]])
72. **Problème du Voyageur de Commerce (TSP)** ([[push_swap/codes/algorithms/72-tsp.c]])
73. **Problème de la Sac à Dos (Knapsack)** ([[push_swap/codes/algorithms/73-knapsack.c]])
74. **Problème des Chemins les Plus Courts** ([[push_swap/codes/algorithms/74-shortest-path.c]])
75. **Problème de la Plus Longue Sous-Séquence Croissante (LIS)** ([[push_swap/codes/algorithms/75-lis.c]])
76. **Problème des Parenthèses Valides** ([[push_swap/codes/algorithms/76-valid-parentheses.c]])
77. **Problème de la Plus Grande Somme Contiguë (Kadane)** ([[push_swap/codes/algorithms/77-kadane.c]])
78. **Problème des Paires de Somme Ciblée** ([[push_swap/codes/algorithms/78-two-sum.c]])
79. **Problème de l'Anagramme** ([[push_swap/codes/algorithms/79-anagram.c]])
80. **Problème du Sous-Tableau Maximum** ([[push_swap/codes/algorithms/80-maximum-subarray.c]])

### f. Algorithmes de Graphes Avancés

81. **Algorithme de Ford-Fulkerson pour le Flux Maximum** ([[push_swap/codes/graph_algorithms/81-ford-fulkerson.c]])
82. **Algorithme de Tarjan pour les Composantes Fortement Connexes** ([[push_swap/codes/graph_algorithms/82-tarjan-cc.c]])
83. **Algorithme de Kosaraju pour les Composantes Fortement Connexes** ([[push_swap/codes/graph_algorithms/83-kosaraju-cc.c]])
84. **Algorithme de Prim Optimisé avec Heaps de Fibonacci** ([[push_swap/codes/graph_algorithms/84-prim-fibonacci.c]])
85. **Algorithme de Johnson pour les Chemins les Plus Courts** ([[push_swap/codes/graph_algorithms/85-johnson-shortest-path.c]])
86. **Topological Sorting** ([[push_swap/codes/graph_algorithms/86-topological-sort.c]])
87. **Détection de Cycles dans un Graphe** ([[push_swap/codes/graph_algorithms/87-cycle-detection.c]])
88. **Algorithme de Bellman-Ford** ([[push_swap/codes/graph_algorithms/88-bellman-ford.c]])
89. **Algorithme de Floyd-Warshall** ([[push_swap/codes/graph_algorithms/89-floyd-warshall.c]])
90. __Algorithme A_ Optimisé_* ([[push_swap/codes/graph_algorithms/90-a-star-optimized.c]])

### g. Programmation Dynamique et Greedy

91. **Programmation Dynamique Avancée** ([[push_swap/codes/dynamic_programming/91-advanced-dp.c]])
92. **Memoization avec Structures de Données** ([[push_swap/codes/dynamic_programming/92-memoization-structures.c]])
93. **Algorithmes Gloutons (Greedy Algorithms)** ([[push_swap/codes/greedy/93-greedy-algorithms.c]])
94. **Optimisation de l'Espace et du Temps** ([[push_swap/codes/optimizations/94-space-time-optimization.c]])
95. **Techniques de Pruning Avancées** ([[push_swap/codes/optimizations/95-advanced-pruning.c]])
96. **Optimisation de la Mémoire** ([[push_swap/codes/optimizations/96-memory-optimization.c]])
97. **Optimisation des Rotations et Reverse Rotations** ([[push_swap/codes/optimizations/97-rotation-optimization.c]])
98. **Minimisation des Opérations de Swap** ([[push_swap/codes/optimizations/98-minimize-swap.c]])
99. **Optimisation des Séquences d'Opérations Simultanées** ([[push_swap/codes/optimizations/99-optimize-simultaneous.c]])
100. **Algorithme de Tri Hybride** ([[push_swap/codes/algorithms/100-hybrid-sort.c]])

---
